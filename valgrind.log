==72== Memcheck, a memory error detector
==72== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==72== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==72== Command: ./push_swap 3 2 1
==72== 
==72== Conditional jump or move depends on uninitialised value(s)
==72==    at 0x109D81: print_list (push_swap.c:21)
==72==    by 0x1092AA: run_algo (algo.c:25)
==72==    by 0x109DF3: push_swap (push_swap.c:39)
==72==    by 0x109E54: main (push_swap.c:66)
==72== 
==72== Conditional jump or move depends on uninitialised value(s)
==72==    at 0x109D81: print_list (push_swap.c:21)
==72==    by 0x109314: run_algo (algo.c:34)
==72==    by 0x109DF3: push_swap (push_swap.c:39)
==72==    by 0x109E54: main (push_swap.c:66)
==72== 
==72== Conditional jump or move depends on uninitialised value(s)
==72==    at 0x109D81: print_list (push_swap.c:21)
==72==    by 0x10940D: run_algo (algo.c:53)
==72==    by 0x109DF3: push_swap (push_swap.c:39)
==72==    by 0x109E54: main (push_swap.c:66)
==72== 
==72== Conditional jump or move depends on uninitialised value(s)
==72==    at 0x109D81: print_list (push_swap.c:21)
==72==    by 0x10938C: run_algo (algo.c:43)
==72==    by 0x109DF3: push_swap (push_swap.c:39)
==72==    by 0x109E54: main (push_swap.c:66)
==72== 
==72== Conditional jump or move depends on uninitialised value(s)
==72==    at 0x10941C: run_algo (algo.c:26)
==72==    by 0x109DF3: push_swap (push_swap.c:39)
==72==    by 0x109E54: main (push_swap.c:66)
==72== 
Push ab
Push ab
Push ab
Liste a : 
Liste b : [1][2][3]
Push ba
Liste a : [1]
Liste b : [2][3]
Push ab
Swap b
Liste a : 
Liste b : [2][1][3]
Push ba
Liste a : [2]
Liste b : [1][3]
Push ba
Liste a : [1][2]
Liste b : [3]
Push ab
Swap b
Liste a : [2]
Liste b : [3][1]
Push ab
Swap b
Liste a : 
Liste b : [3][2][1]
Push ba
Liste a : [3]
Liste b : [2][1]
Push ba
Liste a : [2][3]
Liste b : [1]
Push ba
Liste a : [1][2][3]
Liste b : 
Nombre d'op√©rations : 12
==72== 
==72== HEAP SUMMARY:
==72==     in use at exit: 125 bytes in 10 blocks
==72==   total heap usage: 11 allocs, 1 frees, 4,221 bytes allocated
==72== 
==72== 15 bytes in 3 blocks are definitely lost in loss record 2 of 5
==72==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==72==    by 0x10A072: ft_strjoin (push_swap_utils.c:76)
==72==    by 0x10990A: join_args (input_validation.c:49)
==72==    by 0x109822: input_validation (input_validation.c:23)
==72==    by 0x109DC2: push_swap (push_swap.c:36)
==72==    by 0x109E54: main (push_swap.c:66)
==72== 
==72== 38 (32 direct, 6 indirect) bytes in 1 blocks are definitely lost in loss record 3 of 5
==72==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==72==    by 0x1096E6: ft_split (ft_split.c:89)
==72==    by 0x109879: input_validation (input_validation.c:31)
==72==    by 0x109DC2: push_swap (push_swap.c:36)
==72==    by 0x109E54: main (push_swap.c:66)
==72== 
==72== 72 (24 direct, 48 indirect) bytes in 1 blocks are definitely lost in loss record 5 of 5
==72==    at 0x4848899: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
==72==    by 0x109C3B: create_node (linked_list_creation.c:62)
==72==    by 0x109BAE: create_list (linked_list_creation.c:44)
==72==    by 0x109B2F: array_to_list (linked_list_creation.c:21)
==72==    by 0x109DD2: push_swap (push_swap.c:37)
==72==    by 0x109E54: main (push_swap.c:66)
==72== 
==72== LEAK SUMMARY:
==72==    definitely lost: 71 bytes in 5 blocks
==72==    indirectly lost: 54 bytes in 5 blocks
==72==      possibly lost: 0 bytes in 0 blocks
==72==    still reachable: 0 bytes in 0 blocks
==72==         suppressed: 0 bytes in 0 blocks
==72== 
==72== Use --track-origins=yes to see where uninitialised values come from
==72== For lists of detected and suppressed errors, rerun with: -s
==72== ERROR SUMMARY: 14 errors from 8 contexts (suppressed: 0 from 0)
